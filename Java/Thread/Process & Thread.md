# 프로세스와 스레드
* 하나의 프로세스에는 여러 개의 스레드가 생성됩니다.
    > 단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있습니다.
* 그러므로, 프로세스와 스레드의 관계는 1:N 이라고 할 수 있습니다.
* 스레드는 다른 말로 Lightweight Process(LWP)라고도 합니다.
* 즉, 가벼운 프로세스이고, 프로세스에서 만들어 사용하는 메모리를 공유합니다.
* 그래서 별개의 프로세스가 하나씩 뜨는 것보다 성능이나 자원 사용에 있어 많은 도움이 됩니다.

## stop/suspend와 wait/notify 메소드
* 성능을 높이기 위해 대기 상태의 스레드를 미리 여러 개 만들어 놓고 요청이 들어오면 활성화해 요청을 처리한 후, 다시 대기 상태로 관리합니다.
* 이런 목적에 부합되는 자바 스레드 API에는 stop/suspend 메소드가 있지만 모두 deprecated 되었습니다.

### deprecated된 이유
stop 메소드의 경우
* stop 메소드가 호출되면 해당 스레드가 즉시 멈춥니다.
* 그와 더불어 ThreadDeath 예외가 발생하면서 해당 스레드가 배타적으로 소유하던 모든 객체에 대한 상호 배제 잠금(Mutual Exclusion Lock (이하 뮤택스))이
즉시 해제되어 다른 스레드가 접근할 수 있게 됩니다.
* 여기서 문제는 소유하던 객체가 불안정한 상태일 수도 있다는 것입니다.
* 스레드가 특정 객체에 모니터 잠금을 사용하는 이유는 다른 스레드가 접근하지 못하게 배타적인 권한을 획득한 후 객체의 내부 상태를 변경하기 위해서입니다.
* 그런데 스레드가 객체의 상태를 변경하던 중, stop 메소드가 호출되면 외부 스레드에 모순된 상태의 객체,
즉 상태 변경이 완료되기 전의 형상에 접근할 수 있어 원인을 찾기 어려운 버그가 됩니다.

suspend 메소드의 경우
* 스레드가 특정 리소스에 대한 뮤택스를 획득한 상태에서 suspend 메소드가 호출돼 정지되면,
리소스에 접근하려는 스레드는 suspend된 스레드가 스스로 동작을 재개해 뮤택스를 풀기 전까지 기약 없이 대기해야 하는 문제가 발생합니다.
* 이런 시나리오는 데드락이 발생할 수 있는 대표적인 예입니다.
* 위와 같은 상황을 피하고 스레드를 대기시키거나 진행하려면 wait/notify 메소드 조합을 이용합니다.
    > 자세한 내용은 Thread Class & Runnable Interface를 참고하시기 바랍니다.