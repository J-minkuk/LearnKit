# B-Tree
* 외부 다진 검색 트리입니다.
    > 검색 트리가 HDD에 저장된 상태로 사용되면 이를 외부 검색 트리라고 합니다.<br/>
    트리 형태의 자료구조에서 자식 노드의 수가 2보다 크면 다진 트리라고 합니다.
* DB의 인덱스 구현에 사용됩니다.
* 노드의 크기는 HDD 블럭의 크기입니다.

---

* HDD에서 데이터를 읽고 쓸 경우, 한 바이트씩 읽고 쓰지 않고 한 블럭씩 읽고 씁니다.
    > HDD 파일을 복사할 때 한 바이트씩 읽어서 복사하는 것은,<br>
    파일의 크기만큼 여러 번 HDD를 읽고 써야하기 때문에 매우 비효율적입니다.<br><br>
    한 블럭씩 읽어서 복사한다면 (파일의 크기 / 블럭 크기)만큼만 읽고 쓰면 됩니다.
* HDD에 저장할 자료구조와 알고리즘은 한 블럭 단위로 HDD에 읽고 쓸 수 있도록 고안되어야 합니다.
    > 그래서 HDD에 저장할 트리 형태의 자료구조에서 노드의 크기는 블럭의 크기과 일치하도록 설계됩니다.

---
![B-Tree](./img/B-Tree.png)
* B-Tree의 노드는 HDD 블럭 크기입니다.
* 노드에 들어있는 Key의 수를 ```K``` 개라고 할 때, 자식 노드의 수는 ```K + 1``` 개입니다.

![B-Tree_Node](./img/B-Tree%20Node.png)
* 서브 트리를 T0, T1, T2 ... Tk라고 하면,
* 서브 트리 Ti의 모든 키들은 부모 노드의 Key(i-1) 보다 크고 Key(i)보다 작습니다.

## B-Tree 특성
균형 잡힌 다진 검색 트리로 다음의 성질을 만족합니다.
* **루트를 제외한 모든 노드는 ```K/2 ~ K``` 개의 Key를 갖습니다.**
    > 루트를 제외한 모든 노드는 최소한 반 이상 채워져 있어야 한다는 의미입니다.
* 모든 리프 노드는 같은 Depth를 가집니다.
    > 즉, 모든 리프 노드가 루트 노드로 부터 같은 거리에 있어야 합니다.
* **검색/삽입/삭제 연산의 수행시간은 O(log N)입니다.**
* 항상 균형을 유지해야 하므로, 삽입/삭제가 일어날 때 보조 연산이 필요합니다.
    > 노드의 차수에 여유가 있으면 보조 연산이 필요없지만,<br/>
    차수가 꽉차면 리프 노드의 중간값을 부모 노드로 하여 두 갈래로 분할합니다.

## B-Tree의 노드 구조
![B-Tree_Node_Structure](./img/B-Tree%20Node%20Structure.png)
* 레코드의 Key 값과 그 레코드의 위치가 B-Tree에 저장됩니다.
* 위 그림에서 Key(i)는 레코드의 Key 값이고, P(i)는 그 레코드의 위치입니다.
* **DB의 인덱스는 레코드의 Key 값으로, 그 레코드 위치를 빨리 찾기 위해 사용됩니다.**
    > 학생 테이블의 Key가 학번이라면, 학번으로 학생 레코드를 빨리 찾기 위해 학번 인덱스를 사용합니다.

### 레코드 위치
* **B-Tree에 레코드의 위치를 기록할 때,<br/>
그 레코드가 포함된 HDD 블럭의 번호만 기록하고, 블럭 내의 위치는 기록하지 않습니다.**
* **HDD에서 데이터를 읽을 때, 블럭 전체가 한 번에 읽어지기 때문입니다.**
    > 즉, 어차피 그 레코드가 포함된 블럭 전체가 메모리로 읽어지기 때문입니다.
* **읽어 온 블럭에서 해당 레코드를 찾는 작업은 메모리에서 실행됩니다.**
    > 이 작업에 걸리는 시간은 HDD R/W 작업과 비교해서 무시할 수 있을 정도입니다.
* **레코드의 위치를 기록할 때,<br/>
그 레코드가 포함된 해당 HDD 블럭의 번호만 기록하면 공간을 절약할 수 있는데, 이 이점이 더 큽니다.**

### 자식 노드 위치
* B-Tree 노드에서 자식 노드를 가리키는 참조는 자식 노드 블럭 번호로 구현되어야 합니다.
* B-Tree 노드는 HDD에 기록되기 때문에 자식 노드를 HDD에서 찾아 읽기 위해 블럭 번호가 필요합니다.

---

### B-Tree vs BST
* BST 의 문제점은 좌우 균형이 맞지 않으면 비효율적이라는 것
    > 보통 O(log N) 이지만 O(n) 까지 갈 수 있다.
* B-Tree 는 삽입, 삭제 시 필요하면 스스로 균형을 유지한다.
    > 항상 O(log N)